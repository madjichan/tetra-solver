use std::{
    error::Error,
    env,
    io,
    fs::File,
    io::BufRead,
};

#[derive(Clone, Debug)]
struct Field {
    cells: Vec<Vec<bool>>
}

impl Field {
    fn new(row_count: usize, column_count: usize) -> Field {
        let cells = vec![vec![false; column_count]; row_count];

        Field {
            cells
        }
    }

    fn size(&self) -> (usize, usize) {
        (self.cells.len(), self.cells[0].len())
    }

    fn get(&self, r: usize, c: usize) -> bool {
        self.cells[r][c]
    }

    fn set(&mut self, r: usize, c: usize, v: bool) {
        self.cells[r][c] = v;
    }

    fn up(&mut self, r: usize, c: usize) {
        self.set(r, c, true);
    }

    fn down(&mut self, r: usize, c: usize) {
        self.set(r, c, false);
    }

    #[allow(dead_code)]
    fn can_contain(main: &Field, figure: &Field, figure_coord: (usize, usize)) -> bool {
        let figure_size = figure.size();
        let main_size = main.size();
        figure_coord.0 + figure_size.0 <= main_size.0 && figure_coord.1 + figure_size.1 <= main_size.1
    }

    fn diff(main: &Field, figure: &Field, figure_coord: (usize, usize)) -> Option<Field> {
        let figure_size = figure.size();

        let mut res = Field::new(figure_size.0, figure_size.1);

        for fr in 0..figure_size.0 {
        for fc in 0..figure_size.1 {
            let (mr, mc) = (fr + figure_coord.0, fc + figure_coord.1);
            
            let figure_cell = figure.get(fr, fc);
            let main_cell = main.get(mr, mc);

            if figure_cell && main_cell {
                return None;
            }

            res.set(fr, fc, figure_cell);
        }}

        Some(res)
    }

    fn apply(main: &mut Field, fig_diff: &Field, figure_coord: (usize, usize)) {
        let figdiff_size = fig_diff.size();

        for fr in 0..figdiff_size.0 {
        for fc in 0..figdiff_size.1 {
            let (mr, mc) = (fr + figure_coord.0, fc + figure_coord.1);
            
            let figdiff_cell = fig_diff.get(fr, fc);

            if figdiff_cell {
                main.up(mr, mc);
            }
        }}
    }

    fn undo(main: &mut Field, fig_diff: &Field, figure_coord: (usize, usize)) {
        let figdiff_size = fig_diff.size();

        for fr in 0..figdiff_size.0 {
        for fc in 0..figdiff_size.1 {
            let (mr, mc) = (fr + figure_coord.0, fc + figure_coord.1);
            
            let figdiff_cell = fig_diff.get(fr, fc);

            if figdiff_cell {
                main.down(mr, mc);
            }
        }}
    }
    
    fn next(main: &Field, figure: &Field, figure_coord: (usize, usize)) -> Option<(usize, usize)> {
        let figure_size = figure.size();
        let main_size = main.size();

        if figure_coord.0 + figure_size.0 == main_size.0 && figure_coord.1 + figure_size.1 == main_size.1 {
            None
        }
        else if figure_coord.1 + figure_size.1 == main_size.1 {
            Some((figure_coord.0 + 1, 0))
        }
        else {
            Some((figure_coord.0, figure_coord.1 + 1))
        }
    }
}

struct Solution {
    coords: Vec<Option<(usize, usize)>>,
    fig_diffs: Vec<Option<Field>>,
    current: usize
}

impl Solution {
    fn new(fig_count: usize) -> Solution {
        let mut coords = vec![None; fig_count];
        let fig_diffs = vec![None; fig_count];
        let current = 0;

        coords[0] = Some((0, 0));

        Solution {
            coords,
            fig_diffs,
            current
        }
    }

    fn get_current(&self) -> usize {
        self.current
    }

    fn inc(&mut self) -> usize {
        self.current += 1;
        
        if self.current != self.coords.len() {
            self.coords[self.current] = Some((0, 0));
        }

        self.current
    }

    fn dec(&mut self) -> usize {
        if self.current != self.coords.len() {
            self.coords[self.current] = None;
            self.fig_diffs[self.current] = None;
        }
        self.current -= 1;
        self.current
    }

    fn snapshot(&self) -> Solution {
        Solution {
            coords: self.coords.clone(),
            fig_diffs: self.fig_diffs.clone(),
            current: self.current
        }
    }

    fn next(&mut self, main: &Field, figs: &Vec<Field>) -> bool {
        let opt_coord = Field::next(
            main,
            &figs[self.current],
            self.coords[self.current].unwrap()
        );

        if let Some(coord) = opt_coord {
            self.coords[self.current] = Some(coord);
            true
        } else {
            false
        }
    }

    fn diff(&self, main: &Field, figs: &Vec<Field>) -> Option<Field> {
        Field::diff(
            main,
            &figs[self.current],
            self.coords[self.current].unwrap()
        )
    }

    fn apply(&mut self, main: &mut Field, diff: Field) {
        self.fig_diffs[self.current] = Some(diff);
        
        Field::apply(
            main,
            &self.fig_diffs[self.current].as_ref().unwrap(),
            self.coords[self.current].unwrap()
        );

        self.inc();
    }

    fn undo(&mut self, main: &mut Field) {
        self.dec();

        Field::undo(
            main,
            &self.fig_diffs[self.current].as_ref().unwrap(),
            self.coords[self.current].unwrap()
        );
    }
}

struct Task {
    size: (usize, usize),
    figs: Vec<Field>
}

impl Task {
    fn next_pos(s: &mut Solution, main: &mut Field, figs: &Vec<Field>) -> bool {
        loop { // println!("[ITER NP] {} {:?} {:?}", s.current, s.fig_diffs, s.coords);
            let res = s.next(main, figs);
            if res {
                break;
            }

            if s.get_current() == 0 {
                return false;
            } else {
                s.undo(main);
            }
        }

        true
    }

    fn next(s: &mut Solution, main: &mut Field, figs: &Vec<Field>) -> bool {
        if s.get_current() == figs.len() {
            s.dec();
            let res = Task::next_pos(s, main, figs);
            if !res {
                return false;
            }
        }

        loop { // println!("[ITER N] {} {:?} {:?}", s.current, s.fig_diffs, s.coords);
            let opt_diff = s.diff(main, figs);
            match opt_diff {
                Some(diff) => {
                    s.apply(main, diff);
                    if s.get_current() == figs.len() {
                        break;
                    }
                },
                None => {
                    let res = Task::next_pos(s, main, figs);
                    if !res {
                        return false;
                    }
                }
            }
        }

        true
    }

    fn solve(&self) -> Vec<Solution> {
        let mut res = Vec::new();
        let mut main = Field::new(self.size.0, self.size.1);
        let mut sol = Solution::new(self.figs.len());

        while Task::next(&mut sol, &mut main, &self.figs) {
            res.push(sol.snapshot());
        }

        res
    }

    fn parse_input(mut reader: impl BufRead) -> Result<Task, Box<dyn Error>> {
        let mut inp = String::new();

        reader.read_line(&mut inp)?;
        let size_arr: Vec<usize> = inp.split(' ').map(|x| x.trim().parse().unwrap()).collect();
        if size_arr.len() != 2 {
            panic!("ABOBA");
        }

        reader.read_line(&mut inp)?;
        inp.clear();
        reader.read_line(&mut inp)?;
        let fig_count: usize = inp.trim().parse()?;
        let mut figs = Vec::new();

        for _i in 0..fig_count {
            reader.read_line(&mut inp)?;
            inp.clear();

            reader.read_line(&mut inp)?;
            let fig_size: Vec<usize> = inp.split(' ').map(|x| x.trim().parse().unwrap()).collect();
            if fig_size.len() != 2 {
                panic!("ABOBA");
            }

            let (row_count, column_count) = (fig_size[0], fig_size[1]);
            let mut n_fig = Field::new(row_count, column_count);

            for ri in 0..row_count {
                inp.clear();
                reader.read_line(&mut inp)?;

                let line = inp.trim();

                if line.len() != column_count {
                    panic!("ABOBA");
                }

                let mut it = line.chars();

                for ci in 0..column_count {
                    let c = if let Some(c) = it.next() {
                        c
                    } else {
                        panic!("ABOBA");
                    };

                    match c {
                        '.' => {
                            n_fig.down(ri, ci);
                        },
                        '#' => {
                            n_fig.up(ri, ci);
                        },
                        _ => {
                            panic!("ABOBA");
                        }
                    }
                }
            }

            figs.push(n_fig);
        }

        Ok(Task {
            size: (size_arr[0], size_arr[1]),
            figs 
        })
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        panic!("Wring syntax. Syntax: tetra_solver [filename]");
    }

    let file = File::open(&args[1])?;
    let reader = io::BufReader::new(file);

    let task = Task::parse_input(reader)?;

    let solves = task.solve();

    println!("Founded {} solves", solves.len());

    for (i, s) in solves.iter().enumerate() {
        println!("TASK #{}: {:?}", i, s.coords);
    }

    Ok(())
}
